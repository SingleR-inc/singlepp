<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>singlepp: singlepp Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">singlepp
   </div>
   <div id="projectbrief">A C++ library for cell type classification</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">singlepp Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Cell type classification using the SingleR algorithm in C++.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsinglepp_1_1ChooseClassicMarkersOptions.html">ChooseClassicMarkersOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for <code><a class="el" href="#ae888912441a04acf856e74a9f4a0452b">choose_classic_markers()</a></code>.  <a href="structsinglepp_1_1ChooseClassicMarkersOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsinglepp_1_1ClassifyIntegratedBuffers.html">ClassifyIntegratedBuffers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output buffers for <code><a class="el" href="#ae8772734badf4a09d6c285b9b98295ec" title="Implements the SingleR algorithm for automated annotation of single-cell RNA-seq data.">classify_single()</a></code>.  <a href="structsinglepp_1_1ClassifyIntegratedBuffers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsinglepp_1_1ClassifyIntegratedOptions.html">ClassifyIntegratedOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for <code><a class="el" href="#a60f705dc3fdc122139e2102713e7ec41" title="Integrate classifications from multiple references.">classify_integrated()</a></code>.  <a href="structsinglepp_1_1ClassifyIntegratedOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsinglepp_1_1ClassifyIntegratedResults.html">ClassifyIntegratedResults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Results of <code><a class="el" href="#a60f705dc3fdc122139e2102713e7ec41" title="Integrate classifications from multiple references.">classify_integrated()</a></code>.  <a href="structsinglepp_1_1ClassifyIntegratedResults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsinglepp_1_1ClassifySingleBuffers.html">ClassifySingleBuffers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output buffers for <code><a class="el" href="#ae8772734badf4a09d6c285b9b98295ec" title="Implements the SingleR algorithm for automated annotation of single-cell RNA-seq data.">classify_single()</a></code>.  <a href="structsinglepp_1_1ClassifySingleBuffers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsinglepp_1_1ClassifySingleOptions.html">ClassifySingleOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for <code><a class="el" href="#ae8772734badf4a09d6c285b9b98295ec" title="Implements the SingleR algorithm for automated annotation of single-cell RNA-seq data.">classify_single()</a></code> and friends.  <a href="structsinglepp_1_1ClassifySingleOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsinglepp_1_1ClassifySingleResults.html">ClassifySingleResults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Results of <code><a class="el" href="#ae8772734badf4a09d6c285b9b98295ec" title="Implements the SingleR algorithm for automated annotation of single-cell RNA-seq data.">classify_single()</a></code> and <code><a class="el" href="#ad7d214a5da53597d24dec5cec59e3beb">classify_single_intersect()</a></code>.  <a href="structsinglepp_1_1ClassifySingleResults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinglepp_1_1TrainedIntegrated.html">TrainedIntegrated</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classifier that integrates multiple reference datasets.  <a href="classsinglepp_1_1TrainedIntegrated.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinglepp_1_1TrainedSingle.html">TrainedSingle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classifier trained from a single reference.  <a href="classsinglepp_1_1TrainedSingle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsinglepp_1_1TrainedSingleIntersect.html">TrainedSingleIntersect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classifier built from an intersection of genes.  <a href="classsinglepp_1_1TrainedSingleIntersect.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsinglepp_1_1TrainIntegratedInput.html">TrainIntegratedInput</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input to <code><a class="el" href="#af198ad22e020701691c9bb8326401a46">train_integrated()</a></code>.  <a href="structsinglepp_1_1TrainIntegratedInput.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsinglepp_1_1TrainIntegratedOptions.html">TrainIntegratedOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for <code><a class="el" href="#af198ad22e020701691c9bb8326401a46">train_integrated()</a></code>.  <a href="structsinglepp_1_1TrainIntegratedOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsinglepp_1_1TrainSingleOptions.html">TrainSingleOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for <code><a class="el" href="#a9fc89c91fd655f9b1877f631bf20d352">train_single()</a></code> and friends.  <a href="structsinglepp_1_1TrainSingleOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1d147dc88bf87bef188bd24b56d0f571" id="r_a1d147dc88bf87bef188bd24b56d0f571"><td class="memTemplParams" colspan="2">template&lt;typename Index_  = DefaultIndex&gt; </td></tr>
<tr class="memitem:a1d147dc88bf87bef188bd24b56d0f571"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1d147dc88bf87bef188bd24b56d0f571">Markers</a> = std::vector&lt;std::vector&lt;std::vector&lt;Index_&gt; &gt; &gt;</td></tr>
<tr class="separator:a1d147dc88bf87bef188bd24b56d0f571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c63a73c7c40ad5e6f47ef0f9abac5d" id="r_ae0c63a73c7c40ad5e6f47ef0f9abac5d"><td class="memTemplParams" colspan="2">template&lt;typename Index_  = DefaultIndex&gt; </td></tr>
<tr class="memitem:ae0c63a73c7c40ad5e6f47ef0f9abac5d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae0c63a73c7c40ad5e6f47ef0f9abac5d">Intersection</a> = std::vector&lt;std::pair&lt;Index_, Index_&gt; &gt;</td></tr>
<tr class="separator:ae0c63a73c7c40ad5e6f47ef0f9abac5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75885e26a4870572229427b4acc3e74f" id="r_a75885e26a4870572229427b4acc3e74f"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75885e26a4870572229427b4acc3e74f">DefaultIndex</a></td></tr>
<tr class="separator:a75885e26a4870572229427b4acc3e74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16859be67879a6e0650877f12edd9f14" id="r_a16859be67879a6e0650877f12edd9f14"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16859be67879a6e0650877f12edd9f14">DefaultLabel</a></td></tr>
<tr class="separator:a16859be67879a6e0650877f12edd9f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8cb5a049cb39b52068562ef2c9bbff" id="r_a9e8cb5a049cb39b52068562ef2c9bbff"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e8cb5a049cb39b52068562ef2c9bbff">DefaultRefLabel</a></td></tr>
<tr class="separator:a9e8cb5a049cb39b52068562ef2c9bbff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337b47b25c3bfaff91d30f38fe5bb31b" id="r_a337b47b25c3bfaff91d30f38fe5bb31b"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a337b47b25c3bfaff91d30f38fe5bb31b">DefaultFloat</a></td></tr>
<tr class="separator:a337b47b25c3bfaff91d30f38fe5bb31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ced86db19f4d2cf55ba4310bd2c16d2" id="r_a1ced86db19f4d2cf55ba4310bd2c16d2"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ced86db19f4d2cf55ba4310bd2c16d2">DefaultValue</a></td></tr>
<tr class="separator:a1ced86db19f4d2cf55ba4310bd2c16d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae8772734badf4a09d6c285b9b98295ec" id="r_ae8772734badf4a09d6c285b9b98295ec"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , typename Float_ , typename Label_ &gt; </td></tr>
<tr class="memitem:ae8772734badf4a09d6c285b9b98295ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae8772734badf4a09d6c285b9b98295ec">classify_single</a> (const tatami::Matrix&lt; Value_, Index_ &gt; &amp;test, const <a class="el" href="classsinglepp_1_1TrainedSingle.html">TrainedSingle</a>&lt; Index_, Float_ &gt; &amp;trained, const <a class="el" href="structsinglepp_1_1ClassifySingleBuffers.html">ClassifySingleBuffers</a>&lt; Label_, Float_ &gt; &amp;buffers, const <a class="el" href="structsinglepp_1_1ClassifySingleOptions.html">ClassifySingleOptions</a>&lt; Float_ &gt; &amp;options)</td></tr>
<tr class="memdesc:ae8772734badf4a09d6c285b9b98295ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the <a href="https://bioconductor.org/packages/SingleR"><b>SingleR</b></a> algorithm for automated annotation of single-cell RNA-seq data.  <br /></td></tr>
<tr class="separator:ae8772734badf4a09d6c285b9b98295ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d214a5da53597d24dec5cec59e3beb" id="r_ad7d214a5da53597d24dec5cec59e3beb"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , typename Float_ , typename Label_ &gt; </td></tr>
<tr class="memitem:ad7d214a5da53597d24dec5cec59e3beb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad7d214a5da53597d24dec5cec59e3beb">classify_single_intersect</a> (const tatami::Matrix&lt; Value_, Index_ &gt; &amp;test, const <a class="el" href="classsinglepp_1_1TrainedSingleIntersect.html">TrainedSingleIntersect</a>&lt; Index_, Float_ &gt; &amp;trained, const <a class="el" href="structsinglepp_1_1ClassifySingleBuffers.html">ClassifySingleBuffers</a>&lt; Label_, Float_ &gt; &amp;buffers, const <a class="el" href="structsinglepp_1_1ClassifySingleOptions.html">ClassifySingleOptions</a>&lt; Float_ &gt; &amp;options)</td></tr>
<tr class="separator:ad7d214a5da53597d24dec5cec59e3beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23220206f86fe833bad096526d58db0" id="r_af23220206f86fe833bad096526d58db0"><td class="memTemplParams" colspan="2">template&lt;typename Label_  = DefaultLabel, typename Value_ , typename Index_ , typename Float_ &gt; </td></tr>
<tr class="memitem:af23220206f86fe833bad096526d58db0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsinglepp_1_1ClassifySingleResults.html">ClassifySingleResults</a>&lt; Label_, Float_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af23220206f86fe833bad096526d58db0">classify_single</a> (const tatami::Matrix&lt; Value_, Index_ &gt; &amp;test, const <a class="el" href="classsinglepp_1_1TrainedSingle.html">TrainedSingle</a>&lt; Index_, Float_ &gt; &amp;trained, const <a class="el" href="structsinglepp_1_1ClassifySingleOptions.html">ClassifySingleOptions</a>&lt; Float_ &gt; &amp;options)</td></tr>
<tr class="separator:af23220206f86fe833bad096526d58db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9de543e62eb0ff85b7e5b701406e72" id="r_aaf9de543e62eb0ff85b7e5b701406e72"><td class="memTemplParams" colspan="2">template&lt;typename Label_  = DefaultLabel, typename Value_ , typename Index_ , typename Float_ &gt; </td></tr>
<tr class="memitem:aaf9de543e62eb0ff85b7e5b701406e72"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsinglepp_1_1ClassifySingleResults.html">ClassifySingleResults</a>&lt; Label_, Float_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaf9de543e62eb0ff85b7e5b701406e72">classify_single_intersect</a> (const tatami::Matrix&lt; Value_, Index_ &gt; &amp;test, const <a class="el" href="classsinglepp_1_1TrainedSingleIntersect.html">TrainedSingleIntersect</a>&lt; Index_, Float_ &gt; &amp;trained, const <a class="el" href="structsinglepp_1_1ClassifySingleOptions.html">ClassifySingleOptions</a>&lt; Float_ &gt; &amp;options)</td></tr>
<tr class="separator:aaf9de543e62eb0ff85b7e5b701406e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc89c91fd655f9b1877f631bf20d352" id="r_a9fc89c91fd655f9b1877f631bf20d352"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , typename Label_ , typename Float_ , class Matrix_ &gt; </td></tr>
<tr class="memitem:a9fc89c91fd655f9b1877f631bf20d352"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsinglepp_1_1TrainedSingle.html">TrainedSingle</a>&lt; Index_, Float_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9fc89c91fd655f9b1877f631bf20d352">train_single</a> (const tatami::Matrix&lt; Value_, Index_ &gt; &amp;ref, const Label_ *labels, <a class="el" href="#a1d147dc88bf87bef188bd24b56d0f571">Markers</a>&lt; Index_ &gt; markers, const <a class="el" href="structsinglepp_1_1TrainSingleOptions.html">TrainSingleOptions</a>&lt; Index_, Float_, Matrix_ &gt; &amp;options)</td></tr>
<tr class="separator:a9fc89c91fd655f9b1877f631bf20d352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96846462f632dd26f8113aa97da97c91" id="r_a96846462f632dd26f8113aa97da97c91"><td class="memTemplParams" colspan="2">template&lt;typename Index_ , typename Value_ , typename Label_ , typename Float_ &gt; </td></tr>
<tr class="memitem:a96846462f632dd26f8113aa97da97c91"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsinglepp_1_1TrainedSingleIntersect.html">TrainedSingleIntersect</a>&lt; Index_, Float_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a96846462f632dd26f8113aa97da97c91">train_single_intersect</a> (Index_ test_nrow, const <a class="el" href="#ae0c63a73c7c40ad5e6f47ef0f9abac5d">Intersection</a>&lt; Index_ &gt; &amp;intersection, const tatami::Matrix&lt; Value_, Index_ &gt; &amp;ref, const Label_ *labels, <a class="el" href="#a1d147dc88bf87bef188bd24b56d0f571">Markers</a>&lt; Index_ &gt; markers, const <a class="el" href="structsinglepp_1_1TrainSingleOptions.html">TrainSingleOptions</a>&lt; Index_, Float_ &gt; &amp;options)</td></tr>
<tr class="separator:a96846462f632dd26f8113aa97da97c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093757279cb45fcf7b1df51b71dfc8e1" id="r_a093757279cb45fcf7b1df51b71dfc8e1"><td class="memTemplParams" colspan="2">template&lt;typename Index_ , typename Id_ , typename Value_ , typename Label_ , typename Float_ , class Matrix_ &gt; </td></tr>
<tr class="memitem:a093757279cb45fcf7b1df51b71dfc8e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsinglepp_1_1TrainedSingleIntersect.html">TrainedSingleIntersect</a>&lt; Index_, Float_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a093757279cb45fcf7b1df51b71dfc8e1">train_single_intersect</a> (Index_ test_nrow, const Id_ *test_id, const tatami::Matrix&lt; Value_, Index_ &gt; &amp;ref, const Id_ *ref_id, const Label_ *labels, <a class="el" href="#a1d147dc88bf87bef188bd24b56d0f571">Markers</a>&lt; Index_ &gt; markers, const <a class="el" href="structsinglepp_1_1TrainSingleOptions.html">TrainSingleOptions</a>&lt; Index_, Float_, Matrix_ &gt; &amp;options)</td></tr>
<tr class="separator:a093757279cb45fcf7b1df51b71dfc8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f705dc3fdc122139e2102713e7ec41" id="r_a60f705dc3fdc122139e2102713e7ec41"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , typename Label_ , typename RefLabel_ , typename Float_ &gt; </td></tr>
<tr class="memitem:a60f705dc3fdc122139e2102713e7ec41"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a60f705dc3fdc122139e2102713e7ec41">classify_integrated</a> (const tatami::Matrix&lt; Value_, Index_ &gt; &amp;test, const std::vector&lt; const Label_ * &gt; &amp;assigned, const <a class="el" href="classsinglepp_1_1TrainedIntegrated.html">TrainedIntegrated</a>&lt; Index_ &gt; &amp;trained, <a class="el" href="structsinglepp_1_1ClassifyIntegratedBuffers.html">ClassifyIntegratedBuffers</a>&lt; RefLabel_, Float_ &gt; &amp;buffers, const <a class="el" href="structsinglepp_1_1ClassifyIntegratedOptions.html">ClassifyIntegratedOptions</a>&lt; Float_ &gt; &amp;options)</td></tr>
<tr class="memdesc:a60f705dc3fdc122139e2102713e7ec41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate classifications from multiple references.  <br /></td></tr>
<tr class="separator:a60f705dc3fdc122139e2102713e7ec41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca35f5c98162213d14d4ce801b6376b0" id="r_aca35f5c98162213d14d4ce801b6376b0"><td class="memTemplParams" colspan="2">template&lt;typename RefLabel_  = DefaultRefLabel, typename Value_ , typename Index_ , typename Label_ , typename Float_ &gt; </td></tr>
<tr class="memitem:aca35f5c98162213d14d4ce801b6376b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsinglepp_1_1ClassifyIntegratedResults.html">ClassifyIntegratedResults</a>&lt; RefLabel_, Float_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aca35f5c98162213d14d4ce801b6376b0">classify_integrated</a> (const tatami::Matrix&lt; Value_, Index_ &gt; &amp;test, const std::vector&lt; const Label_ * &gt; &amp;assigned, const <a class="el" href="classsinglepp_1_1TrainedIntegrated.html">TrainedIntegrated</a>&lt; Index_ &gt; &amp;trained, const <a class="el" href="structsinglepp_1_1ClassifyIntegratedOptions.html">ClassifyIntegratedOptions</a>&lt; Float_ &gt; &amp;options)</td></tr>
<tr class="separator:aca35f5c98162213d14d4ce801b6376b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280f3bfb8b5a2e7e51233bc7382a8db1" id="r_a280f3bfb8b5a2e7e51233bc7382a8db1"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , typename Label_ , typename Float_ &gt; </td></tr>
<tr class="memitem:a280f3bfb8b5a2e7e51233bc7382a8db1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsinglepp_1_1TrainIntegratedInput.html">TrainIntegratedInput</a>&lt; Value_, Index_, Label_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a280f3bfb8b5a2e7e51233bc7382a8db1">prepare_integrated_input</a> (const tatami::Matrix&lt; Value_, Index_ &gt; &amp;ref, const Label_ *labels, const <a class="el" href="classsinglepp_1_1TrainedSingle.html">TrainedSingle</a>&lt; Index_, Float_ &gt; &amp;trained)</td></tr>
<tr class="separator:a280f3bfb8b5a2e7e51233bc7382a8db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da95a907514caf12c99a9f3fd83aa20" id="r_a5da95a907514caf12c99a9f3fd83aa20"><td class="memTemplParams" colspan="2">template&lt;typename Index_ , typename Value_ , typename Label_ , typename Float_ &gt; </td></tr>
<tr class="memitem:a5da95a907514caf12c99a9f3fd83aa20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsinglepp_1_1TrainIntegratedInput.html">TrainIntegratedInput</a>&lt; Value_, Index_, Label_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5da95a907514caf12c99a9f3fd83aa20">prepare_integrated_input_intersect</a> (Index_ test_nrow, const <a class="el" href="#ae0c63a73c7c40ad5e6f47ef0f9abac5d">Intersection</a>&lt; Index_ &gt; &amp;intersection, const tatami::Matrix&lt; Value_, Index_ &gt; &amp;ref, const Label_ *labels, const <a class="el" href="classsinglepp_1_1TrainedSingleIntersect.html">TrainedSingleIntersect</a>&lt; Index_, Float_ &gt; &amp;trained)</td></tr>
<tr class="separator:a5da95a907514caf12c99a9f3fd83aa20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e0f072fe5fa1844313198ef1e64918" id="r_a55e0f072fe5fa1844313198ef1e64918"><td class="memTemplParams" colspan="2">template&lt;typename Index_ , typename Id_ , typename Value_ , typename Label_ , typename Float_ &gt; </td></tr>
<tr class="memitem:a55e0f072fe5fa1844313198ef1e64918"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsinglepp_1_1TrainIntegratedInput.html">TrainIntegratedInput</a>&lt; Value_, Index_, Label_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a55e0f072fe5fa1844313198ef1e64918">prepare_integrated_input_intersect</a> (Index_ test_nrow, const Id_ *test_id, const tatami::Matrix&lt; Value_, Index_ &gt; &amp;ref, const Id_ *ref_id, const Label_ *labels, const <a class="el" href="classsinglepp_1_1TrainedSingleIntersect.html">TrainedSingleIntersect</a>&lt; Index_, Float_ &gt; &amp;trained)</td></tr>
<tr class="separator:a55e0f072fe5fa1844313198ef1e64918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af198ad22e020701691c9bb8326401a46" id="r_af198ad22e020701691c9bb8326401a46"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , typename Label_ &gt; </td></tr>
<tr class="memitem:af198ad22e020701691c9bb8326401a46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsinglepp_1_1TrainedIntegrated.html">TrainedIntegrated</a>&lt; Index_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af198ad22e020701691c9bb8326401a46">train_integrated</a> (const std::vector&lt; <a class="el" href="structsinglepp_1_1TrainIntegratedInput.html">TrainIntegratedInput</a>&lt; Value_, Index_, Label_ &gt; &gt; &amp;inputs, const <a class="el" href="structsinglepp_1_1TrainIntegratedOptions.html">TrainIntegratedOptions</a> &amp;options)</td></tr>
<tr class="separator:af198ad22e020701691c9bb8326401a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e0dfffaed84685432ad2a39cc12a97" id="r_a82e0dfffaed84685432ad2a39cc12a97"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , typename Label_ &gt; </td></tr>
<tr class="memitem:a82e0dfffaed84685432ad2a39cc12a97"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsinglepp_1_1TrainedIntegrated.html">TrainedIntegrated</a>&lt; Index_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a82e0dfffaed84685432ad2a39cc12a97">train_integrated</a> (std::vector&lt; <a class="el" href="structsinglepp_1_1TrainIntegratedInput.html">TrainIntegratedInput</a>&lt; Value_, Index_, Label_ &gt; &gt; &amp;&amp;inputs, const <a class="el" href="structsinglepp_1_1TrainIntegratedOptions.html">TrainIntegratedOptions</a> &amp;options)</td></tr>
<tr class="separator:a82e0dfffaed84685432ad2a39cc12a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b70c4d5949e28af164723543361214" id="r_a22b70c4d5949e28af164723543361214"><td class="memTemplParams" colspan="2">template&lt;typename Index_ , typename Id_ &gt; </td></tr>
<tr class="memitem:a22b70c4d5949e28af164723543361214"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#ae0c63a73c7c40ad5e6f47ef0f9abac5d">Intersection</a>&lt; Index_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a22b70c4d5949e28af164723543361214">intersect_genes</a> (Index_ test_nrow, const Id_ *test_id, Index_ ref_nrow, const Id_ *ref_id)</td></tr>
<tr class="separator:a22b70c4d5949e28af164723543361214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26ab7d42558905cab72d85e509cfb0c" id="r_ac26ab7d42558905cab72d85e509cfb0c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac26ab7d42558905cab72d85e509cfb0c">number_of_classic_markers</a> (size_t num_labels)</td></tr>
<tr class="separator:ac26ab7d42558905cab72d85e509cfb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae888912441a04acf856e74a9f4a0452b" id="r_ae888912441a04acf856e74a9f4a0452b"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , typename Label_ &gt; </td></tr>
<tr class="memitem:ae888912441a04acf856e74a9f4a0452b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a1d147dc88bf87bef188bd24b56d0f571">Markers</a>&lt; Index_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae888912441a04acf856e74a9f4a0452b">choose_classic_markers</a> (const std::vector&lt; const tatami::Matrix&lt; Value_, Index_ &gt; * &gt; &amp;representatives, const std::vector&lt; const Label_ * &gt; &amp;labels, const <a class="el" href="structsinglepp_1_1ChooseClassicMarkersOptions.html">ChooseClassicMarkersOptions</a> &amp;options)</td></tr>
<tr class="separator:ae888912441a04acf856e74a9f4a0452b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b37c9c0ac535f7c85771fbeb98e4df" id="r_ae6b37c9c0ac535f7c85771fbeb98e4df"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , typename Label_ &gt; </td></tr>
<tr class="memitem:ae6b37c9c0ac535f7c85771fbeb98e4df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a1d147dc88bf87bef188bd24b56d0f571">Markers</a>&lt; Index_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae6b37c9c0ac535f7c85771fbeb98e4df">choose_classic_markers</a> (const tatami::Matrix&lt; Value_, Index_ &gt; &amp;representative, const Label_ *labels, const <a class="el" href="structsinglepp_1_1ChooseClassicMarkersOptions.html">ChooseClassicMarkersOptions</a> &amp;options)</td></tr>
<tr class="separator:ae6b37c9c0ac535f7c85771fbeb98e4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Cell type classification using the SingleR algorithm in C++. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a337b47b25c3bfaff91d30f38fe5bb31b" name="a337b47b25c3bfaff91d30f38fe5bb31b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a337b47b25c3bfaff91d30f38fe5bb31b">&#9670;&#160;</a></span>DefaultFloat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="#a337b47b25c3bfaff91d30f38fe5bb31b">singlepp::DefaultFloat</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default type for the <code>Float_</code> template argument. This is the type for the correlations and classification scores. </p>

</div>
</div>
<a id="a75885e26a4870572229427b4acc3e74f" name="a75885e26a4870572229427b4acc3e74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75885e26a4870572229427b4acc3e74f">&#9670;&#160;</a></span>DefaultIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="#a75885e26a4870572229427b4acc3e74f">singlepp::DefaultIndex</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default type for the <code>Index_</code> template argument. This is the type for the gene (and sample) indices, typically from the row/column indices of a <code>tatami::Matrix</code>. </p>

</div>
</div>
<a id="a16859be67879a6e0650877f12edd9f14" name="a16859be67879a6e0650877f12edd9f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16859be67879a6e0650877f12edd9f14">&#9670;&#160;</a></span>DefaultLabel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="#a16859be67879a6e0650877f12edd9f14">singlepp::DefaultLabel</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default type for the <code>Label_</code> template argument. This is the type for the label identifiers within each reference. </p>

</div>
</div>
<a id="a9e8cb5a049cb39b52068562ef2c9bbff" name="a9e8cb5a049cb39b52068562ef2c9bbff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8cb5a049cb39b52068562ef2c9bbff">&#9670;&#160;</a></span>DefaultRefLabel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="#a9e8cb5a049cb39b52068562ef2c9bbff">singlepp::DefaultRefLabel</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default type for the <code>RefLabel_</code> template argument. This is the type for the reference identifiers during integrated classification. </p>

</div>
</div>
<a id="a1ced86db19f4d2cf55ba4310bd2c16d2" name="a1ced86db19f4d2cf55ba4310bd2c16d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ced86db19f4d2cf55ba4310bd2c16d2">&#9670;&#160;</a></span>DefaultValue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="#a1ced86db19f4d2cf55ba4310bd2c16d2">singlepp::DefaultValue</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default type for the <code>Value_</code> template argument. This is the type for input data in the <code>tatami::Matrix</code>. </p>

</div>
</div>
<a id="ae0c63a73c7c40ad5e6f47ef0f9abac5d" name="ae0c63a73c7c40ad5e6f47ef0f9abac5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c63a73c7c40ad5e6f47ef0f9abac5d">&#9670;&#160;</a></span>Intersection</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_  = DefaultIndex&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae0c63a73c7c40ad5e6f47ef0f9abac5d">singlepp::Intersection</a> = std::vector&lt;std::pair&lt;Index_, Index_&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Intersection of genes between two datasets. Each pair represents a gene that is present in both datasets. The two elements of the pair represent the row indices of that gene in the respective matrices.</p>
<p>Typically, the first element of the pair contains the row index of a gene in the test dataset, while the second element of the pair contains the row index of the same gene in the reference dataset. This convention is used by <code><a class="el" href="#a22b70c4d5949e28af164723543361214">intersect_genes()</a></code>, <code><a class="el" href="#a96846462f632dd26f8113aa97da97c91">train_single_intersect()</a></code> and <code><a class="el" href="#a5da95a907514caf12c99a9f3fd83aa20">prepare_integrated_input_intersect()</a></code>.</p>
<p>A row index for a matrix should occur no more than once in the <code>Intersection</code> object. That is, all the first elements should be unique and all of the second elements should be unique. Pairs may be arbitrarily ordered within the object.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the gene (row) indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d147dc88bf87bef188bd24b56d0f571" name="a1d147dc88bf87bef188bd24b56d0f571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d147dc88bf87bef188bd24b56d0f571">&#9670;&#160;</a></span>Markers</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_  = DefaultIndex&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a1d147dc88bf87bef188bd24b56d0f571">singlepp::Markers</a> = std::vector&lt;std::vector&lt;std::vector&lt;Index_&gt; &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A vector of vectors of marker lists, with one list for each pairwise comparison between labels in the reference dataset. This is used to determine which genes should be used to compute correlations in <code><a class="el" href="#a9fc89c91fd655f9b1877f631bf20d352">train_single()</a></code> and <code><a class="el" href="#a96846462f632dd26f8113aa97da97c91">train_single_intersect()</a></code>.</p>
<p>For a <code>Markers</code> object <code>markers</code>, let us consider the vector at <code>markers[0][1]</code>. This vector should contain a list of marker genes for label 0 compared to label 1. Each gene is represented as the row index of the reference expression matrix, i.e., <code>ref</code> in <code><a class="el" href="#a9fc89c91fd655f9b1877f631bf20d352">train_single()</a></code> and <code><a class="el" href="#a96846462f632dd26f8113aa97da97c91">train_single_intersect()</a></code>. The vector should also be sorted by the "strength" of the markers such that the earliest entries are the strongest markers for that pairwise comparison. Typically, this vector is created by identifying the genes that are upregulated in label 0 compared to 1 and sorting by decreasing effect size. So, for example, <code>markers[0][1][0]</code> should contain the row index of the most upregulated gene in this comparison.</p>
<p>For a given reference dataset, the corresponding <code>Markers</code> object should have length equal to the number of labels in that reference. Each middle vector (i.e., <code>markers[i]</code> for non-negative <code>i</code> less than the number of labels) should also have length equal to the number of labels. Any innermost vector along the "diagonal" (i.e., <code>markers[i][i]</code>) is typically of zero length. The innermost vectors that are not on the diagonal (i.e., <code>markers[i][j]</code> for <code>i != j</code>) may be of any positive length and should contain unique row indices. Note that the length of all innermost vectors will be be capped by any non-negative <code><a class="el" href="structsinglepp_1_1TrainSingleOptions.html#af45ac859255a937e08684870d12ab123">TrainSingleOptions::top</a></code> in <code><a class="el" href="#a9fc89c91fd655f9b1877f631bf20d352">train_single()</a></code> and friends.</p>
<p>As mentioned above, the diagonal innermost vectors are typically empty, given that it makes little sense to identify upregulated markers in a label compared to itself. That said, any genes stored on the diagonal will be respected and used in all gene subsets for the corresponding label. This can be exploited by advanced users to efficiently store "universal" markers for a label, i.e., markers that are applicable in all comparisons to other labels.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the gene (row) indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae888912441a04acf856e74a9f4a0452b" name="ae888912441a04acf856e74a9f4a0452b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae888912441a04acf856e74a9f4a0452b">&#9670;&#160;</a></span>choose_classic_markers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , typename Label_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a1d147dc88bf87bef188bd24b56d0f571">Markers</a>&lt; Index_ &gt; singlepp::choose_classic_markers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const tatami::Matrix&lt; Value_, Index_ &gt; * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>representatives</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const Label_ * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>labels</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsinglepp_1_1ChooseClassicMarkersOptions.html">ChooseClassicMarkersOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#ae888912441a04acf856e74a9f4a0452b">choose_classic_markers()</a></code> that handles multiple references. When choosing markers for label \(A\) against \(B\), we only consider those references with both labels \(A\) and \(B\). For each gene, we compute the log-fold change within each reference, and then sum the log-fold changes across references; the ordering of the top genes is then performed using this sum. It is assumed that all references have the same number and ordering of features in their rows.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Numeric type of matrix values. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type of matrix row/column indices. </td></tr>
    <tr><td class="paramname">Label_</td><td>Integer type for the label identity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">representatives</td><td>Vector of pointers to representative <b>tatami</b> matrices. Each matrix should contain no more than one column per label. Each column should contain a "representative" log-expression profile for that label, e.g., using the per-gene median expression across all samples assigned to that label. All matrices should have the same number of rows, corresponding to the same features. </td></tr>
    <tr><td class="paramname">labels</td><td>Vector of pointers of length equal to <code>representatives</code>. Each array should be of length equal to the number of columns of the corresponding entry of <code>representatives</code>. Each value of the array should specify the label for the corresponding column in its matrix. Values should lie in \([0, L)\) for \(L\) unique labels across all entries of <code>labels</code>. </td></tr>
    <tr><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Top markers for each pairwise comparison between labels. </dd></dl>

</div>
</div>
<a id="ae6b37c9c0ac535f7c85771fbeb98e4df" name="ae6b37c9c0ac535f7c85771fbeb98e4df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b37c9c0ac535f7c85771fbeb98e4df">&#9670;&#160;</a></span>choose_classic_markers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , typename Label_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a1d147dc88bf87bef188bd24b56d0f571">Markers</a>&lt; Index_ &gt; singlepp::choose_classic_markers </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; Value_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>representative</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Label_ *</td>          <td class="paramname"><span class="paramname"><em>labels</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsinglepp_1_1ChooseClassicMarkersOptions.html">ChooseClassicMarkersOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implements the classic <b>SingleR</b> method for choosing markers from (typically bulk) reference datasets. We assume that we have a matrix of representative expression profiles for each label, typically computed by averaging across all reference profiles for that label. For the comparison between labels \(A\) and \(B\), we define the marker set as the top genes with the largest positive differences in \(A\)'s profile over \(B\). This difference can be interpreted as the log-fold change if the input matrix contains log-expression values. If multiple genes have the same difference, ties are broken by favoring genes in earlier rows of the input matrix. The number of top genes can either be explicitly specified or it can be automatically determined from the number of labels.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Numeric type of matrix values. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type of matrix row/column indices. </td></tr>
    <tr><td class="paramname">Label_</td><td>Integer type for the label identity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">representative</td><td>A representative matrix, containing one column per label. Each column should have a representative log-expression profile for that label. </td></tr>
    <tr><td class="paramname">labels</td><td>Pointer to an array of length equal to the number of columns in <code>representative</code>. Each value of the array should specify the label for the corresponding column. Values should lie in \([0, L)\) for \(L\) unique labels. </td></tr>
    <tr><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Top markers for each pairwise comparison between labels. </dd></dl>

</div>
</div>
<a id="a60f705dc3fdc122139e2102713e7ec41" name="a60f705dc3fdc122139e2102713e7ec41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60f705dc3fdc122139e2102713e7ec41">&#9670;&#160;</a></span>classify_integrated() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , typename Label_ , typename RefLabel_ , typename Float_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void singlepp::classify_integrated </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; Value_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>test</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const Label_ * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>assigned</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsinglepp_1_1TrainedIntegrated.html">TrainedIntegrated</a>&lt; Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>trained</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsinglepp_1_1ClassifyIntegratedBuffers.html">ClassifyIntegratedBuffers</a>&lt; RefLabel_, Float_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsinglepp_1_1ClassifyIntegratedOptions.html">ClassifyIntegratedOptions</a>&lt; Float_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integrate classifications from multiple references. </p>
<p>When multiple reference datasets are available, we would like to obtain a single prediction for each cell from all of those references. This is somewhat tricky as different references tend to have inconsistent labels, e.g., different vocabularies and cell subtype resolutions, making it difficult to define sensible groups in a combined "super-reference". Strong batch effects are also likely to exist between different references, complicating the choice of marker genes when comparing between labels of different references.</p>
<p>To avoid these issues, we first perform classification within each individual reference using, e.g., <code><a class="el" href="#ae8772734badf4a09d6c285b9b98295ec" title="Implements the SingleR algorithm for automated annotation of single-cell RNA-seq data.">classify_single()</a></code>. For each test cell, we collect all the marker genes for that cell's predicted label in each reference. We pool all of these collected markers to obtain a common set of interesting genes. Using this common set of genes, we compute the usual correlation-based score between the test cell's expression profile and its predicted label from each reference, along with some fine-tuning iterations to improve resolution between similar labels. The label with the highest score is considered the best representative across all references.</p>
<p>This method is similar to the algorithm described in <code><a class="el" href="#ae8772734badf4a09d6c285b9b98295ec" title="Implements the SingleR algorithm for automated annotation of single-cell RNA-seq data.">classify_single()</a></code>, except that we are choosing between the best labels from all references rather than between all labels from one reference. The creation of a common gene set ensures that the correlations can be reasonably compared across references. (Note that differences in the gene sets across references are tolerated by simply ignoring missing genes when computing the correlations. This reduces the comparability of the scores as the actual genes used for each reference will vary; nonetheless, it is preferred to taking the intersection, which is liable to leave us with very few genes.)</p>
<p>Our approach avoids any direct comparison between the expression profiles of different references, allowing us to side-step the question of how to deal with the batch effects. Similarly, we defer responsibility on solving the issue of label heterogeneity, by just passing along the existing labels and leaving it to the user's interpretation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Numeric type for the matrix values. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Label_</td><td>Integer type for the labels within each reference. </td></tr>
    <tr><td class="paramname">RefLabel_</td><td>Integer type for the label to represent each reference. </td></tr>
    <tr><td class="paramname">Float_</td><td>Floating-point type for the correlations and scores.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">test</td><td>Expression matrix of the test dataset, where rows are genes and columns are cells. The identity of the rows should be consistent with the reference datasets used to construct <code>trained</code>, see <code><a class="el" href="#a280f3bfb8b5a2e7e51233bc7382a8db1">prepare_integrated_input()</a></code> and <code><a class="el" href="#a5da95a907514caf12c99a9f3fd83aa20">prepare_integrated_input_intersect()</a></code> for details. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">assigned</td><td>Vector of pointers of length equal to the number of references. Each pointer should point to an array of length equal to the number of columns in <code>test</code>, containing the assigned label for each column in each reference. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">trained</td><td>The integrated classifier returned by <code><a class="el" href="#af198ad22e020701691c9bb8326401a46">train_integrated()</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffers</td><td>Buffers in which to store the classification output. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca35f5c98162213d14d4ce801b6376b0" name="aca35f5c98162213d14d4ce801b6376b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca35f5c98162213d14d4ce801b6376b0">&#9670;&#160;</a></span>classify_integrated() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RefLabel_  = DefaultRefLabel, typename Value_ , typename Index_ , typename Label_ , typename Float_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsinglepp_1_1ClassifyIntegratedResults.html">ClassifyIntegratedResults</a>&lt; RefLabel_, Float_ &gt; singlepp::classify_integrated </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; Value_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>test</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const Label_ * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>assigned</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsinglepp_1_1TrainedIntegrated.html">TrainedIntegrated</a>&lt; Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>trained</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsinglepp_1_1ClassifyIntegratedOptions.html">ClassifyIntegratedOptions</a>&lt; Float_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#a60f705dc3fdc122139e2102713e7ec41" title="Integrate classifications from multiple references.">classify_integrated()</a></code> that allocates space for the results.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">test</td><td>Expression matrix of the test dataset, where rows are genes and columns are cells. The identity of the rows should be consistent with the reference datasets used to construct <code>trained</code>, see <code><a class="el" href="#a280f3bfb8b5a2e7e51233bc7382a8db1">prepare_integrated_input()</a></code> and <code><a class="el" href="#a5da95a907514caf12c99a9f3fd83aa20">prepare_integrated_input_intersect()</a></code> for details. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">assigned</td><td>Vector of pointers of length equal to the number of references. Each pointer should point to an array of length equal to the number of columns in <code>mat</code>, containing the assigned label for each column in each reference. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">trained</td><td>A pre-built classifier produced by <code><a class="el" href="#af198ad22e020701691c9bb8326401a46">train_integrated()</a></code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object containing the best reference and associated scores for each cell in <code>test</code>. </dd></dl>

</div>
</div>
<a id="ae8772734badf4a09d6c285b9b98295ec" name="ae8772734badf4a09d6c285b9b98295ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8772734badf4a09d6c285b9b98295ec">&#9670;&#160;</a></span>classify_single() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , typename Float_ , typename Label_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void singlepp::classify_single </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; Value_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>test</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsinglepp_1_1TrainedSingle.html">TrainedSingle</a>&lt; Index_, Float_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>trained</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsinglepp_1_1ClassifySingleBuffers.html">ClassifySingleBuffers</a>&lt; Label_, Float_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsinglepp_1_1ClassifySingleOptions.html">ClassifySingleOptions</a>&lt; Float_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements the <a href="https://bioconductor.org/packages/SingleR"><b>SingleR</b></a> algorithm for automated annotation of single-cell RNA-seq data. </p>
<p>For each cell, we compute the Spearman rank correlation between that cell and the reference expression profiles. This is done using only the subset of genes that are label-specific markers, most typically the top genes from pairwise comparisons between each label's expression profiles (see <code><a class="el" href="#ae888912441a04acf856e74a9f4a0452b">choose_classic_markers()</a></code> for an example). For each label, we take the correlations involving that label's reference profiles and convert it into a score. The label with the highest score is used as an initial label for that cell.</p>
<p>Next, we apply fine-tuning iterations to improve the label accuracy for each cell by refining the feature space. We find the subset of labels with scores that are "close enough" to the maximum score according to some threshold. We recompute the scores using only the markers for this subset of labels, and we repeat the process until only one label is left or the subset of labels no longer changes. At the end of the iterations, the label with the highest score (or the only label, if just one is left) is used as the label for the cell. This process aims to remove noise by eliminating irrelevant genes when attempting to distinguish closely related labels.</p>
<p>Each label's score is defined as a user-specified quantile of the distribution of correlations across all reference profiles assigned to that label. Larger quantiles focus on similarity between the test cell and the closest profiles for a label, which is useful for broad labels with heterogeneous profiles. Smaller quantiles require the test cell to be similar to the majority of profiles for a label. The use of a quantile ensures that the score adjusts to the number of reference profiles per label; otherwise, just using the "top X correlations" would implicitly favor labels with more reference profiles.</p>
<p>The choice of Spearman's correlation provides some robustness against batch effects when comparing reference and test datasets. Only the relative expression <em>within</em> each cell needs to be comparable, not their relative expression across cells. As a result, it does not matter whether raw counts are supplied or log-transformed expression values, as the latter is a monotonic transformation of the latter (within each cell). The algorithm is also robust to differences in technologies between reference and test profiles, though it is preferable to have like-for-like comparisons.</p>
<dl class="section see"><dt>See also</dt><dd>Aran D et al. (2019). Reference-based analysis of lung single-cell sequencing reveals a transitional profibrotic macrophage. <em>Nat. Immunol.</em> 20, 163-172</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Numeric type for the matrix values. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Float_</td><td>Floating-point type for the correlations and scores. </td></tr>
    <tr><td class="paramname">Label_</td><td>Integer type for the reference labels.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">test</td><td>Expression matrix of the test dataset, where rows are genes and columns are cells. This should have the same order and identity of genes as the reference matrix used to create <code>trained</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">trained</td><td>Classifier returned by <code><a class="el" href="#a9fc89c91fd655f9b1877f631bf20d352">train_single()</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffers</td><td>Buffers in which to store the classification output. Each non-<code>NULL</code> pointer should refer to an array of length equal to the number of columns in <code>test</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af23220206f86fe833bad096526d58db0" name="af23220206f86fe833bad096526d58db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af23220206f86fe833bad096526d58db0">&#9670;&#160;</a></span>classify_single() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Label_  = DefaultLabel, typename Value_ , typename Index_ , typename Float_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsinglepp_1_1ClassifySingleResults.html">ClassifySingleResults</a>&lt; Label_, Float_ &gt; singlepp::classify_single </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; Value_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>test</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsinglepp_1_1TrainedSingle.html">TrainedSingle</a>&lt; Index_, Float_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>trained</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsinglepp_1_1ClassifySingleOptions.html">ClassifySingleOptions</a>&lt; Float_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#ae8772734badf4a09d6c285b9b98295ec" title="Implements the SingleR algorithm for automated annotation of single-cell RNA-seq data.">classify_single()</a></code> that allocates space for the output statistics.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Label_</td><td>Integer type for the reference labels. </td></tr>
    <tr><td class="paramname">Value_</td><td>Numeric type for the matrix values. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Float_</td><td>Floating-point type for the correlations and scores.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test</td><td>Expression matrix of the test dataset, where rows are genes and columns are cells. This should have the same order and identity of genes as the reference matrix used to create <code>trained</code>. </td></tr>
    <tr><td class="paramname">trained</td><td>Classifier returned by <code><a class="el" href="#a9fc89c91fd655f9b1877f631bf20d352">train_single()</a></code>. </td></tr>
    <tr><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Results of the classification for each cell in the test dataset. </dd></dl>

</div>
</div>
<a id="ad7d214a5da53597d24dec5cec59e3beb" name="ad7d214a5da53597d24dec5cec59e3beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7d214a5da53597d24dec5cec59e3beb">&#9670;&#160;</a></span>classify_single_intersect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , typename Float_ , typename Label_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void singlepp::classify_single_intersect </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; Value_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>test</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsinglepp_1_1TrainedSingleIntersect.html">TrainedSingleIntersect</a>&lt; Index_, Float_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>trained</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsinglepp_1_1ClassifySingleBuffers.html">ClassifySingleBuffers</a>&lt; Label_, Float_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsinglepp_1_1ClassifySingleOptions.html">ClassifySingleOptions</a>&lt; Float_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Variant of <code><a class="el" href="#ae8772734badf4a09d6c285b9b98295ec" title="Implements the SingleR algorithm for automated annotation of single-cell RNA-seq data.">classify_single()</a></code> that should be used when the test and reference datasets do not have the same number/order of genes. This is done by limiting the classification to the intersection of genes between the two datasets.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Numeric type for the matrix values. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Label_</td><td>Integer type for the reference labels. </td></tr>
    <tr><td class="paramname">Float_</td><td>Floating-point type for the correlations and scores.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">test</td><td>Expression matrix of the test dataset, where rows are genes and columns are cells. This should have the same order and identity of genes as the <code>test_nrow</code> and <code>test_id</code> used to create <code>trained</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">trained</td><td>Classifier returned by <code><a class="el" href="#a96846462f632dd26f8113aa97da97c91">train_single_intersect()</a></code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffers</td><td>Buffers in which to store the classification output. Each non-<code>NULL</code> pointer should refer to an array of length equal to the number of columns in <code>test</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf9de543e62eb0ff85b7e5b701406e72" name="aaf9de543e62eb0ff85b7e5b701406e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf9de543e62eb0ff85b7e5b701406e72">&#9670;&#160;</a></span>classify_single_intersect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Label_  = DefaultLabel, typename Value_ , typename Index_ , typename Float_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsinglepp_1_1ClassifySingleResults.html">ClassifySingleResults</a>&lt; Label_, Float_ &gt; singlepp::classify_single_intersect </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; Value_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>test</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsinglepp_1_1TrainedSingleIntersect.html">TrainedSingleIntersect</a>&lt; Index_, Float_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>trained</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsinglepp_1_1ClassifySingleOptions.html">ClassifySingleOptions</a>&lt; Float_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#ad7d214a5da53597d24dec5cec59e3beb">classify_single_intersect()</a></code> that allocates space for the output statistics.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Label_</td><td>Integer type for the reference labels. </td></tr>
    <tr><td class="paramname">Value_</td><td>Numeric type for the matrix values. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices. </td></tr>
    <tr><td class="paramname">Float_</td><td>Floating-point type for the correlations and scores.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test</td><td>Expression matrix of the test dataset, where rows are genes and columns are cells. This should have the same order and identity of genes as the <code>test_nrow</code> and <code>test_ids</code> used to create <code>trained</code>. </td></tr>
    <tr><td class="paramname">trained</td><td>Classifier returned by <code><a class="el" href="#a96846462f632dd26f8113aa97da97c91">train_single_intersect()</a></code>. </td></tr>
    <tr><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Results of the classification for each cell in the test dataset. </dd></dl>

</div>
</div>
<a id="a22b70c4d5949e28af164723543361214" name="a22b70c4d5949e28af164723543361214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b70c4d5949e28af164723543361214">&#9670;&#160;</a></span>intersect_genes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ , typename Id_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae0c63a73c7c40ad5e6f47ef0f9abac5d">Intersection</a>&lt; Index_ &gt; singlepp::intersect_genes </td>
          <td>(</td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>test_nrow</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Id_ *</td>          <td class="paramname"><span class="paramname"><em>test_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>ref_nrow</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Id_ *</td>          <td class="paramname"><span class="paramname"><em>ref_id</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the intersection of genes in the test and reference datasets.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the row indices of genes in each dataset. Also used as the type for the number of genes. </td></tr>
    <tr><td class="paramname">Id_</td><td>Type of the gene identifier, typically an integer or string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">test_nrow</td><td>Number of genes (i.e., rows) in the test dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">test_id</td><td>Pointer to an array of length <code>test_nrow</code>, containing the gene identifiers for each row in the test dataset. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ref_nrow</td><td>Number of genes (i.e., rows) in the reference dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ref_id</td><td>Pointer to an array of length <code>ref_nrow</code>, containing the gene identifiers for each row in the reference dataset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Intersection of genes between the two datasets. The first entry of each pair contains the row index in the test dataset while the second entry contains the row index in the reference. If duplicated identifiers are present in either of <code>test_id</code> or <code>ref_id</code>, only the first occurrence is considered in the intersection. </dd></dl>

</div>
</div>
<a id="ac26ab7d42558905cab72d85e509cfb0c" name="ac26ab7d42558905cab72d85e509cfb0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26ab7d42558905cab72d85e509cfb0c">&#9670;&#160;</a></span>number_of_classic_markers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t singlepp::number_of_classic_markers </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>num_labels</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Choose the number of markers in <code><a class="el" href="#ae888912441a04acf856e74a9f4a0452b">choose_classic_markers()</a></code>. The exact expression is defined as \(500 (\frac{2}{3})^{\log_2{L}}\) for \(L\) labels, which steadily decreases the markers per comparison as the number of labels increases. This aims to avoid an excessive number of features when dealing with references with many labels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_labels</td><td>Number of labels in the reference(s).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An appropriate number of markers for each pairwise comparison. </dd></dl>

</div>
</div>
<a id="a280f3bfb8b5a2e7e51233bc7382a8db1" name="a280f3bfb8b5a2e7e51233bc7382a8db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a280f3bfb8b5a2e7e51233bc7382a8db1">&#9670;&#160;</a></span>prepare_integrated_input()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , typename Label_ , typename Float_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsinglepp_1_1TrainIntegratedInput.html">TrainIntegratedInput</a>&lt; Value_, Index_, Label_ &gt; singlepp::prepare_integrated_input </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; Value_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ref</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Label_ *</td>          <td class="paramname"><span class="paramname"><em>labels</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsinglepp_1_1TrainedSingle.html">TrainedSingle</a>&lt; Index_, Float_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>trained</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepare a reference dataset for <code><a class="el" href="#af198ad22e020701691c9bb8326401a46">train_integrated()</a></code>. This overload assumes that the reference and test datasets have the same genes. <code>ref</code> and <code>labels</code> are expected to remain valid until <code><a class="el" href="#af198ad22e020701691c9bb8326401a46">train_integrated()</a></code> is called.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Numeric type for the matrix values. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices of the matrix. </td></tr>
    <tr><td class="paramname">Label_</td><td>Integer type for the reference labels. </td></tr>
    <tr><td class="paramname">Float_</td><td>Floating-point type for the correlations and scores.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ref</td><td>Matrix containing the reference expression values, where rows are genes and columns are reference profiles. The number and identity of genes should be identical to the test dataset to be classified in <code><a class="el" href="#a60f705dc3fdc122139e2102713e7ec41" title="Integrate classifications from multiple references.">classify_integrated()</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">labels</td><td>Pointer to an array of label assignments. Values should be integers in \([0, L)\) where \(L\) is the number of unique labels. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">trained</td><td>Classifier created by calling <code><a class="el" href="#a9fc89c91fd655f9b1877f631bf20d352">train_single()</a></code> on <code>ref</code> and <code>labels</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An opaque input object for <code><a class="el" href="#af198ad22e020701691c9bb8326401a46">train_integrated()</a></code>. </dd></dl>

</div>
</div>
<a id="a55e0f072fe5fa1844313198ef1e64918" name="a55e0f072fe5fa1844313198ef1e64918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e0f072fe5fa1844313198ef1e64918">&#9670;&#160;</a></span>prepare_integrated_input_intersect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ , typename Id_ , typename Value_ , typename Label_ , typename Float_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsinglepp_1_1TrainIntegratedInput.html">TrainIntegratedInput</a>&lt; Value_, Index_, Label_ &gt; singlepp::prepare_integrated_input_intersect </td>
          <td>(</td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>test_nrow</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Id_ *</td>          <td class="paramname"><span class="paramname"><em>test_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tatami::Matrix&lt; Value_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ref</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Id_ *</td>          <td class="paramname"><span class="paramname"><em>ref_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Label_ *</td>          <td class="paramname"><span class="paramname"><em>labels</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsinglepp_1_1TrainedSingleIntersect.html">TrainedSingleIntersect</a>&lt; Index_, Float_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>trained</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepare a reference dataset for <code><a class="el" href="#af198ad22e020701691c9bb8326401a46">train_integrated()</a></code>. This overload automatically identifies the intersection of genes between the test and reference datasets. <code>ref</code> and <code>labels</code> are expected to remain valid until <code><a class="el" href="#af198ad22e020701691c9bb8326401a46">train_integrated()</a></code> is called.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices of the matrix. </td></tr>
    <tr><td class="paramname">Id_</td><td>Type of the gene identifier. </td></tr>
    <tr><td class="paramname">Value_</td><td>Numeric type for the matrix values. </td></tr>
    <tr><td class="paramname">Label_</td><td>Integer type for the reference labels. </td></tr>
    <tr><td class="paramname">Float_</td><td>Floating-point type for the correlations and scores.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">test_nrow</td><td>Number of rows (i.e., genes) in the test dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">test_id</td><td>Pointer to an array of length equal to <code>test_nrow</code>. This should contain a unique identifier for each row of <code>mat</code>, typically a gene name or index. If any duplicate IDs are present, only the first occurrence is used. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ref</td><td>An expression matrix for the reference expression profiles, where rows are genes and columns are cells. This should have non-zero columns. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ref_id</td><td>Pointer to an array equal to the number of rows of <code>ref</code>. This should contain a unique identifier for each row in <code>ref</code>, comparable to those in <code>test_id</code>. If any duplicate IDs are present, only the first occurrence is used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">labels</td><td>An array of length equal to the number of columns of <code>ref</code>, containing the label for each sample. Values should be integers in \([0, L)\) where \(L\) is the number of unique labels. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">trained</td><td>Classifier created by calling <code><a class="el" href="#a96846462f632dd26f8113aa97da97c91">train_single_intersect()</a></code> on <code>test_nrow</code>, <code>test_id</code>, <code>ref</code>, <code>ref_id</code> and <code>labels</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An opaque input object for <code><a class="el" href="#af198ad22e020701691c9bb8326401a46">train_integrated()</a></code>. </dd></dl>

</div>
</div>
<a id="a5da95a907514caf12c99a9f3fd83aa20" name="a5da95a907514caf12c99a9f3fd83aa20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da95a907514caf12c99a9f3fd83aa20">&#9670;&#160;</a></span>prepare_integrated_input_intersect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ , typename Value_ , typename Label_ , typename Float_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsinglepp_1_1TrainIntegratedInput.html">TrainIntegratedInput</a>&lt; Value_, Index_, Label_ &gt; singlepp::prepare_integrated_input_intersect </td>
          <td>(</td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>test_nrow</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ae0c63a73c7c40ad5e6f47ef0f9abac5d">Intersection</a>&lt; Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>intersection</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tatami::Matrix&lt; Value_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ref</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Label_ *</td>          <td class="paramname"><span class="paramname"><em>labels</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsinglepp_1_1TrainedSingleIntersect.html">TrainedSingleIntersect</a>&lt; Index_, Float_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>trained</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepare a reference dataset for <code><a class="el" href="#af198ad22e020701691c9bb8326401a46">train_integrated()</a></code>. This overload requires an existing intersection between the test and reference datasets. <code>intersection</code>, <code>ref</code> and <code>labels</code> are expected to remain valid until <code><a class="el" href="#af198ad22e020701691c9bb8326401a46">train_integrated()</a></code> is called.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices of the matrix. </td></tr>
    <tr><td class="paramname">Value_</td><td>Numeric type for the matrix values. </td></tr>
    <tr><td class="paramname">Label_</td><td>Integer type for the reference labels. </td></tr>
    <tr><td class="paramname">Float_</td><td>Floating-point type for the correlations and scores.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">test_nrow</td><td>Number of features in the test dataset. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">intersection</td><td>Vector defining the intersection of genes between the test and reference datasets. Each pair corresponds to a gene where the first and second elements represent the row indices of that gene in the test and reference matrices, respectively. The first element of each pair should be non-negative and less than <code>test_nrow</code>, while the second element should be non-negative and less than <code>ref-&gt;nrow()</code>. See <code><a class="el" href="#a22b70c4d5949e28af164723543361214">intersect_genes()</a></code> for more details. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ref</td><td>Matrix containing the reference expression values, where rows are genes and columns are reference profiles. The number and identity of genes should be consistent with <code>intersection</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">labels</td><td>An array of length equal to the number of columns of <code>ref</code>, containing the label for each sample. Values should be integers in \([0, L)\) where \(L\) is the number of unique labels. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">trained</td><td>Classifier created by calling <code><a class="el" href="#a96846462f632dd26f8113aa97da97c91">train_single_intersect()</a></code> on <code>test_nrow</code>, <code>intersection</code>, <code>ref</code> and <code>labels</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An opaque input object for <code><a class="el" href="#af198ad22e020701691c9bb8326401a46">train_integrated()</a></code>. </dd></dl>

</div>
</div>
<a id="af198ad22e020701691c9bb8326401a46" name="af198ad22e020701691c9bb8326401a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af198ad22e020701691c9bb8326401a46">&#9670;&#160;</a></span>train_integrated() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , typename Label_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsinglepp_1_1TrainedIntegrated.html">TrainedIntegrated</a>&lt; Index_ &gt; singlepp::train_integrated </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structsinglepp_1_1TrainIntegratedInput.html">TrainIntegratedInput</a>&lt; Value_, Index_, Label_ &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>inputs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsinglepp_1_1TrainIntegratedOptions.html">TrainIntegratedOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Numeric type for the matrix values. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices of the matrix. </td></tr>
    <tr><td class="paramname">Label_</td><td>Integer type for the reference labels.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputs</td><td>Vector of references, typically constructed with <code><a class="el" href="#a280f3bfb8b5a2e7e51233bc7382a8db1">prepare_integrated_input()</a></code> or <code><a class="el" href="#a5da95a907514caf12c99a9f3fd83aa20">prepare_integrated_input_intersect()</a></code>. </td></tr>
    <tr><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pre-built classifier that integrates multiple references, for use in <code><a class="el" href="#a60f705dc3fdc122139e2102713e7ec41" title="Integrate classifications from multiple references.">classify_integrated()</a></code>. </dd></dl>

</div>
</div>
<a id="a82e0dfffaed84685432ad2a39cc12a97" name="a82e0dfffaed84685432ad2a39cc12a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e0dfffaed84685432ad2a39cc12a97">&#9670;&#160;</a></span>train_integrated() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , typename Label_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsinglepp_1_1TrainedIntegrated.html">TrainedIntegrated</a>&lt; Index_ &gt; singlepp::train_integrated </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structsinglepp_1_1TrainIntegratedInput.html">TrainIntegratedInput</a>&lt; Value_, Index_, Label_ &gt; &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>inputs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsinglepp_1_1TrainIntegratedOptions.html">TrainIntegratedOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Numeric type for the matrix values. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices of the matrix. </td></tr>
    <tr><td class="paramname">Label_</td><td>Integer type for the reference labels.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputs</td><td>Vector of references, typically constructed with <code><a class="el" href="#a280f3bfb8b5a2e7e51233bc7382a8db1">prepare_integrated_input()</a></code> or <code><a class="el" href="#a5da95a907514caf12c99a9f3fd83aa20">prepare_integrated_input_intersect()</a></code>. </td></tr>
    <tr><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pre-built classifier that integrates multiple references, for use in <code><a class="el" href="#a60f705dc3fdc122139e2102713e7ec41" title="Integrate classifications from multiple references.">classify_integrated()</a></code>. </dd></dl>

</div>
</div>
<a id="a9fc89c91fd655f9b1877f631bf20d352" name="a9fc89c91fd655f9b1877f631bf20d352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc89c91fd655f9b1877f631bf20d352">&#9670;&#160;</a></span>train_single()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , typename Label_ , typename Float_ , class Matrix_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsinglepp_1_1TrainedSingle.html">TrainedSingle</a>&lt; Index_, Float_ &gt; singlepp::train_single </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; Value_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ref</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Label_ *</td>          <td class="paramname"><span class="paramname"><em>labels</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1d147dc88bf87bef188bd24b56d0f571">Markers</a>&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>markers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsinglepp_1_1TrainSingleOptions.html">TrainSingleOptions</a>&lt; Index_, Float_, Matrix_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepare a single labelled reference dataset for use in <code><a class="el" href="#ae8772734badf4a09d6c285b9b98295ec" title="Implements the SingleR algorithm for automated annotation of single-cell RNA-seq data.">classify_single()</a></code>. This involves pre-ranking the markers based on their expression in each reference profile, so that the Spearman correlations can be computed without repeated sorting. We also construct neighbor search indices for rapid calculation of the classification score.</p>
<p>The classifier returned by this function should only be used in <code><a class="el" href="#ae8772734badf4a09d6c285b9b98295ec" title="Implements the SingleR algorithm for automated annotation of single-cell RNA-seq data.">classify_single()</a></code> with a test dataset that has the same genes as the reference dataset. If the test dataset has different genes, consider using <code><a class="el" href="#a96846462f632dd26f8113aa97da97c91">train_single_intersect()</a></code> instead.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Numeric type for the matrix values. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices of the matrix. </td></tr>
    <tr><td class="paramname">Label_</td><td>Integer type for the reference labels. </td></tr>
    <tr><td class="paramname">Float_</td><td>Floating-point type for the correlations and scores. </td></tr>
    <tr><td class="paramname">Matrix_</td><td>Class of the input data for the neighbor search. This should satisfy the <code><a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Matrix.html">knncolle::Matrix</a></code> interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ref</td><td>Matrix for the reference expression profiles. Rows are genes while columns are profiles. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">labels</td><td>An array of length equal to the number of columns of <code>ref</code>, containing the label for each reference profile. Labels should be integers in \([0, L)\) where \(L\) is the total number of unique labels. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">markers</td><td>A vector of vectors of ranked marker genes for each pairwise comparison between labels, see <code><a class="el" href="#a1d147dc88bf87bef188bd24b56d0f571">singlepp::Markers</a></code> for more details. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pre-built classifier that can be used in <code><a class="el" href="#ae8772734badf4a09d6c285b9b98295ec" title="Implements the SingleR algorithm for automated annotation of single-cell RNA-seq data.">classify_single()</a></code> with a test dataset. </dd></dl>

</div>
</div>
<a id="a093757279cb45fcf7b1df51b71dfc8e1" name="a093757279cb45fcf7b1df51b71dfc8e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a093757279cb45fcf7b1df51b71dfc8e1">&#9670;&#160;</a></span>train_single_intersect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ , typename Id_ , typename Value_ , typename Label_ , typename Float_ , class Matrix_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsinglepp_1_1TrainedSingleIntersect.html">TrainedSingleIntersect</a>&lt; Index_, Float_ &gt; singlepp::train_single_intersect </td>
          <td>(</td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>test_nrow</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Id_ *</td>          <td class="paramname"><span class="paramname"><em>test_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tatami::Matrix&lt; Value_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ref</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Id_ *</td>          <td class="paramname"><span class="paramname"><em>ref_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Label_ *</td>          <td class="paramname"><span class="paramname"><em>labels</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1d147dc88bf87bef188bd24b56d0f571">Markers</a>&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>markers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsinglepp_1_1TrainSingleOptions.html">TrainSingleOptions</a>&lt; Index_, Float_, Matrix_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Variant of <code><a class="el" href="#a9fc89c91fd655f9b1877f631bf20d352">train_single()</a></code> that uses the intersection of genes between the reference dataset and a (future) test dataset. This is useful when the genes are not in the same order and number across the test and reference datasets.</p>
<p>The classifier returned by this function should only be used in <code><a class="el" href="#ad7d214a5da53597d24dec5cec59e3beb">classify_single_intersect()</a></code> with a test dataset that has <code>test_nrow</code> rows with the same order and identity of genes as in <code>test_id</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices of the matrix. </td></tr>
    <tr><td class="paramname">Id_</td><td>Type of the gene identifier for each row, typically integer or string. </td></tr>
    <tr><td class="paramname">Value_</td><td>Numeric type for the matrix values. </td></tr>
    <tr><td class="paramname">Label_</td><td>Integer type for the reference labels. </td></tr>
    <tr><td class="paramname">Float_</td><td>Floating-point type for the correlations and scores. </td></tr>
    <tr><td class="paramname">Matrix_</td><td>Class of the input data for the neighbor search. This should satisfy the <code><a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Matrix.html">knncolle::Matrix</a></code> interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">test_nrow</td><td>Number of rows (genes) in the test dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">test_id</td><td>Pointer to an array of length equal to <code>test_nrow</code>, containing a gene identifier for each row of the test dataset. If any duplicate IDs are present, only the first occurrence is used. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ref</td><td>An expression matrix for the reference expression profiles, where rows are genes and columns are cells. This should have non-zero columns. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ref_id</td><td>Pointer to an array of length equal to the number of rows of <code>ref</code>, containing a gene identifier for each row of the reference dataset. Identifiers should be comparable to those in <code>test_id</code>. If any duplicate IDs are present, only the first occurrence is used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">labels</td><td>An array of length equal to the number of columns of <code>ref</code>, containing the label for each reference profile. Labels should be integers in \([0, L)\) where \(L\) is the total number of unique labels. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">markers</td><td>A vector of vectors of ranked marker genes for each pairwise comparison between labels, see <code><a class="el" href="#a1d147dc88bf87bef188bd24b56d0f571">singlepp::Markers</a></code> for more details. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pre-built classifier that can be used in <code><a class="el" href="#ad7d214a5da53597d24dec5cec59e3beb">classify_single_intersect()</a></code>. </dd></dl>

</div>
</div>
<a id="a96846462f632dd26f8113aa97da97c91" name="a96846462f632dd26f8113aa97da97c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96846462f632dd26f8113aa97da97c91">&#9670;&#160;</a></span>train_single_intersect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ , typename Value_ , typename Label_ , typename Float_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsinglepp_1_1TrainedSingleIntersect.html">TrainedSingleIntersect</a>&lt; Index_, Float_ &gt; singlepp::train_single_intersect </td>
          <td>(</td>
          <td class="paramtype">Index_</td>          <td class="paramname"><span class="paramname"><em>test_nrow</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ae0c63a73c7c40ad5e6f47ef0f9abac5d">Intersection</a>&lt; Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>intersection</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tatami::Matrix&lt; Value_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ref</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Label_ *</td>          <td class="paramname"><span class="paramname"><em>labels</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1d147dc88bf87bef188bd24b56d0f571">Markers</a>&lt; Index_ &gt;</td>          <td class="paramname"><span class="paramname"><em>markers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsinglepp_1_1TrainSingleOptions.html">TrainSingleOptions</a>&lt; Index_, Float_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Variant of <code><a class="el" href="#a9fc89c91fd655f9b1877f631bf20d352">train_single()</a></code> that uses a pre-computed intersection of genes between the reference dataset and an as-yet-unspecified test dataset. Most users will prefer to use the other <code><a class="el" href="#a96846462f632dd26f8113aa97da97c91">train_single_intersect()</a></code> overload that accepts <code>test_id</code> and <code>ref_id</code> and computes the intersection automatically.</p>
<p>The classifier returned by this function should only be used in <code><a class="el" href="#ad7d214a5da53597d24dec5cec59e3beb">classify_single_intersect()</a></code> with a test dataset that is compatible with the mappings in <code>intersection</code>. That is, the gene in the <code>intersection[i].first</code>-th row of the test dataset should correspond to the <code>intersection[i].second</code>-th row of the reference dataset.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the row/column indices of the matrix. </td></tr>
    <tr><td class="paramname">Value_</td><td>Numeric type for the matrix values. </td></tr>
    <tr><td class="paramname">Label_</td><td>Integer type for the reference labels. </td></tr>
    <tr><td class="paramname">Float_</td><td>Floating-point type for the correlations and scores. </td></tr>
    <tr><td class="paramname">Matrix_</td><td>Class of the input data for the neighbor search. This should satisfy the <code><a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Matrix.html">knncolle::Matrix</a></code> interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">test_nrow</td><td>Number of features in the test dataset. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">intersection</td><td>Vector defining the intersection of genes between the test and reference datasets. Each pair corresponds to a gene where the first and second elements represent the row indices of that gene in the test and reference matrices, respectively. The first element of each pair should be non-negative and less than <code>test_nrow</code>, while the second element should be non-negative and less than <code>ref-&gt;nrow()</code>. See <code><a class="el" href="#a22b70c4d5949e28af164723543361214">intersect_genes()</a></code> for more details. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ref</td><td>An expression matrix for the reference expression profiles, where rows are genes and columns are cells. This should have non-zero columns. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">labels</td><td>An array of length equal to the number of columns of <code>ref</code>, containing the label for each reference profile. Labels should be integers in \([0, L)\) where \(L\) is the total number of unique labels. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">markers</td><td>A vector of vectors of ranked marker genes for each pairwise comparison between labels, see <code><a class="el" href="#a1d147dc88bf87bef188bd24b56d0f571">singlepp::Markers</a></code> for more details. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pre-built classifier that can be used in <code><a class="el" href="#ad7d214a5da53597d24dec5cec59e3beb">classify_single_intersect()</a></code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
